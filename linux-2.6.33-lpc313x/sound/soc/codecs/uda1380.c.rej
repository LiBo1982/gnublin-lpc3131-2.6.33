--- sound/soc/codecs/uda1380.c
+++ sound/soc/codecs/uda1380.c
@@ -281,6 +281,7 @@
 	SOC_SINGLE("DAC Polarity inverting Switch", UDA1380_MIXER, 15, 1, 0),	/* DA_POL_INV */
 	SOC_ENUM("Noise Shaper", uda1380_sel_ns_enum),				/* SEL_NS */
 	SOC_ENUM("Digital Mixer Signal Control", uda1380_mix_enum),		/* MIX_POS, MIX */
+	SOC_SINGLE("Silence Switch", UDA1380_MIXER, 7, 1, 0),			/* SILENCE, force DAC output to silence */
 	SOC_SINGLE("Silence Detector Switch", UDA1380_MIXER, 6, 1, 0),		/* SDET_ON */
 	SOC_ENUM("Silence Detector Setting", uda1380_sdet_enum),		/* SD_VALUE */
 	SOC_ENUM("Oversampling Input", uda1380_os_enum),			/* OS */
@@ -558,6 +559,24 @@
 	uda1380_write(codec, UDA1380_CLK, clk);
 }
 
+static int uda1380_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 mute_reg = uda1380_read_reg_cache(codec, UDA1380_DEEMP) & ~R13_MTM;
+
+	/* FIXME: mute(codec,0) is called when the magician clock is already
+	 * set to WSPLL, but for some unknown reason writing to interpolator
+	 * registers works only when clocked by SYSCLK */
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	uda1380_write(codec, UDA1380_CLK, ~R00_DAC_CLK & clk);
+	if (mute)
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg | R13_MTM);
+	else
+		uda1380_write(codec, UDA1380_DEEMP, mute_reg);
+	uda1380_write(codec, UDA1380_CLK, clk);
+	return 0;
+}
+
 static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 	enum snd_soc_bias_level level)
 {
@@ -587,6 +606,7 @@
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_both,
 };
 
@@ -594,6 +614,7 @@
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_playback,
 };
 
@@ -601,6 +622,7 @@
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
 	.trigger	= uda1380_trigger,
+	.digital_mute = uda1380_mute,
 	.set_fmt	= uda1380_set_dai_fmt_capture,
 };
 
@@ -753,22 +775,26 @@
 		return -EINVAL;
 	}
 
-	if (!pdata || !pdata->gpio_power || !pdata->gpio_reset)
+	if (!pdata) {
+		dev_err(codec->dev, "Bad platform data\n");
 		return -EINVAL;
+	}
 
-	ret = gpio_request(pdata->gpio_power, "uda1380 power");
-	if (ret)
-		goto err_out;
-	ret = gpio_request(pdata->gpio_reset, "uda1380 reset");
-	if (ret)
-		goto err_gpio;
+	if ( pdata->gpio_power && pdata->gpio_reset) {
+		ret = gpio_request(pdata->gpio_power, "uda1380 power");
+		if (ret)
+			goto err_out;
+		ret = gpio_request(pdata->gpio_reset, "uda1380 reset");
+		if (ret)
+			goto err_gpio;
 
-	gpio_direction_output(pdata->gpio_power, 1);
+		gpio_direction_output(pdata->gpio_power, 1);
 
-	/* we may need to have the clock running here - pH5 */
-	gpio_direction_output(pdata->gpio_reset, 1);
-	udelay(5);
-	gpio_set_value(pdata->gpio_reset, 0);
+		/* we may need to have the clock running here - pH5 */
+		gpio_direction_output(pdata->gpio_reset, 1);
+		udelay(5);
+		gpio_set_value(pdata->gpio_reset, 0);
+	}
 
 	mutex_init(&codec->mutex);
 	INIT_LIST_HEAD(&codec->dapm_widgets);
@@ -819,10 +845,13 @@
 err_dai:
 	snd_soc_unregister_codec(codec);
 err_reset:
-	gpio_set_value(pdata->gpio_power, 0);
-	gpio_free(pdata->gpio_reset);
+	if ( pdata->gpio_power && pdata->gpio_reset) {
+		gpio_set_value(pdata->gpio_power, 0);
+		gpio_free(pdata->gpio_reset);
+	}
 err_gpio:
-	gpio_free(pdata->gpio_power);
+	if ( pdata->gpio_power)
+		gpio_free(pdata->gpio_power);
 err_out:
 	return ret;
 }
@@ -835,9 +864,11 @@
 	snd_soc_unregister_dais(uda1380_dai, ARRAY_SIZE(uda1380_dai));
 	snd_soc_unregister_codec(&uda1380->codec);
 
-	gpio_set_value(pdata->gpio_power, 0);
-	gpio_free(pdata->gpio_reset);
-	gpio_free(pdata->gpio_power);
+	if ( pdata->gpio_power || pdata->gpio_reset) {
+		gpio_set_value(pdata->gpio_power, 0);
+		gpio_free(pdata->gpio_reset);
+		gpio_free(pdata->gpio_power);
+	}
 
 	kfree(uda1380);
 	uda1380_codec = NULL;
