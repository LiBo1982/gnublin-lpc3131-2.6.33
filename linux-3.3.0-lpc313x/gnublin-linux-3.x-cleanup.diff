--- a/arch/arm/tools/mach-types	2012-08-21 22:55:26.256945126 +0200
+++ b/arch/arm/tools/mach-types	2012-08-26 12:07:11.145231909 +0200
@@ -1209,5 +1209,6 @@ da850_pqab		MACH_DA850_PQAB		DA850_PQAB
 val3153			MACH_VAL3153		VAL3153			9999
 val3154			MACH_VAL3154		VAL3154			9997
 ea3152			MACH_EA3152		EA3152			9996
+gnublin			MACH_GNUBLIN		GNUBLIN			9995
 
 
--- a/arch/arm/mach-lpc31xx/board-gnublin.c	2012-08-21 22:55:26.133612465 +0200
+++ b/arch/arm/mach-lpc31xx/board-gnublin.c	2012-08-26 13:21:22.477162728 +0200
@@ -1,10 +1,11 @@
-/*  arch/arm/mach-lpc313x/ea313x.c
+/*  arch/arm/mach-lpc31xx/board-gnublin.c
  *
+ *  gnublin board init routines.
+ *
+ *  based on ea313x.c
  *  Author:	Durgesh Pattamatta
  *  Copyright (C) 2009 NXP semiconductors
  *
- *  ea313x board init routines.
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -24,13 +25,10 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
-#include <linux/dm9000.h>
-#include <linux/spi/ads7846.h>
 #include <linux/i2c.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/spi/spi.h>
-#include <linux/leds-pca9532.h>
 #include <linux/gpio.h>
 
 #include <asm/system.h>
@@ -164,145 +162,6 @@ static struct platform_device	lpc313x_mc
 	.resource	= lpc313x_mci_resources,
 };
 
-#if defined (CONFIG_FB_SSD1289)
-static struct resource ssd1289_resource[] = {
-	[0] = {
-		.start = EXT_SRAM0_PHYS + 0x00000 + 0x0000,
-		.end   = EXT_SRAM0_PHYS + 0x00000 + 0xffff,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = EXT_SRAM0_PHYS + 0x10000 + 0x0000,
-		.end   = EXT_SRAM0_PHYS + 0x10000 + 0xffff,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device ssd1289_device = {
-	.name          = "ssd1289",
-	.id            = 0,
-	.num_resources = ARRAY_SIZE(ssd1289_resource),
-	.resource      = ssd1289_resource,
-};
-
-static void __init ea_add_device_ssd1289(void)
-{
-	MPMC_STCONFIG0 = 0x81;
-	MPMC_STWTWEN0  = 0;
-	MPMC_STWTOEN0  = 0;
-	MPMC_STWTRD0   = 31;
-	MPMC_STWTPG0   = 0;
-	MPMC_STWTWR0   = 3;
-	MPMC_STWTTURN0 = 0;
-
-	platform_device_register(&ssd1289_device);
-}
-#else
-static void __init ea_add_device_ssd1289(void) {}
-#endif /* CONFIG_SSD1289 */
-
-/*
- * DM9000 ethernet device
- */
-#if defined(CONFIG_DM9000)
-static struct resource dm9000_resource[] = {
-	[0] = {
-		.start	= EXT_SRAM1_PHYS,
-		.end	= EXT_SRAM1_PHYS + 0xFF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= EXT_SRAM1_PHYS + 0x10000,
-		.end	= EXT_SRAM1_PHYS + 0x100FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start	= IRQ_DM9000_ETH_INT,
-		.end	= IRQ_DM9000_ETH_INT,
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	}
-};
-/* ARM MPMC contoller as part of low power design doesn't de-assert nCS and nOE for consecutive 
-reads but just changes address. But DM9000 requires nCS and nOE change between address. So access
-other chip select area (nCS0) to force de-assertion of nCS1 and nOE1. Or else wait for long time 
-such as 80 usecs. 
-LPC313x has external logic outside of MPMC IP to toggle nOE to split consecutive reads.
-The latest Apex bootloader pacth makes use of this feture.
-For this to work SYS_MPMC_WTD_DEL0 & SYS_MPMC_WTD_DEL1 should be programmed with MPMC_STWTRD0
-& MPMC_STWTRD1 values. The logic only deactivates the nOE for one clock cycle which is
-11nsec but DM9000 needs 80nsec between nOEs. So lets add some dummy instructions such as
-reading a GPIO register to compensate for extra 70nsec.
-*/
-# define DM_IO_DELAY()	do { gpio_get_value(GPIO_MNAND_RYBN3);} while(0)
-
-static void dm9000_dumpblk(void __iomem *reg, int count)
-{
-	int i;
-	int tmp;
-
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		tmp = readw(reg);
-	}
-}
-
-static void dm9000_inblk(void __iomem *reg, void *data, int count)
-{
-	int i;
-	u16* pdata = (u16*)data;
-	count = (count + 1) >> 1;
-	for (i = 0; i < count; i++) {
-		DM_IO_DELAY();
-		*pdata++ = readw(reg);
-	}
-}
-
-static struct dm9000_plat_data dm9000_platdata = {
-	.flags		= DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM | DM9000_PLATF_SIMPLE_PHY,
-	.dumpblk = dm9000_dumpblk,
-	.inblk = dm9000_inblk,
-};
-
-static struct platform_device dm9000_device = {
-	.name		= "dm9000",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(dm9000_resource),
-	.resource	= dm9000_resource,
-	.dev		= {
-		.platform_data	= &dm9000_platdata,
-	}
-};
-static void __init ea_add_device_dm9000(void)
-{
-	/*
-	 * Configure Chip-Select 2 on SMC for the DM9000.
-	 * Note: These timings were calculated for MASTER_CLOCK = 90000000
-	 *  according to the DM9000 timings.
-	 */
-	MPMC_STCONFIG1 = 0x81;
-	MPMC_STWTWEN1 = 1;
-	MPMC_STWTOEN1 = 1;
-	MPMC_STWTRD1 = 4;
-	MPMC_STWTPG1 = 1;
-	MPMC_STWTWR1 = 1;
-	MPMC_STWTTURN1 = 2;
-	/* enable oe toggle between consec reads */
-	SYS_MPMC_WTD_DEL1 = _BIT(5) | 4;
-
-	/* Configure Interrupt pin as input, no pull-up */
-	if (gpio_request(GPIO_MNAND_RYBN3, "dm9000 interrupt"))
-		return;
-
-	gpio_direction_input(GPIO_MNAND_RYBN3);
-
-	platform_device_register(&dm9000_device);
-}
-#else
-static void __init ea_add_device_dm9000(void) {}
-#endif /* CONFIG_DM9000 */
-
-
 #if defined (CONFIG_MTD_NAND_LPC313X)
 static struct resource lpc313x_nand_resources[] = {
 	[0] = {
@@ -471,18 +330,6 @@ struct lpc313x_spi_chip {
 	void (*cs_control)(u32 command);
 };
 
-static struct ads7846_platform_data ea313x_ads7846_info = {
-	.model			= 7846,
-	.vref_delay_usecs	= 100,
-	.x_plate_ohms		= 419,
-	.y_plate_ohms		= 486,
-	.gpio_pendown		= GPIO_GPIO4,
-};
-
-static struct lpc313x_spi_chip ea313x_ads7846_chip = {
-	.gpio_cs	= GPIO_MUART_CTS_N,
-};
-
 /* If both SPIDEV and MTD data flash are enabled with the same chip select, only 1 will work */
 #if defined(CONFIG_SPI_SPIDEV)
 /* SPIDEV driver registration */
@@ -494,21 +341,9 @@ static int __init lpc313x_spidev_registe
 		.max_speed_hz = 1000000,
 		.bus_num = 0,
 		.chip_select = 0,
-	}, {
-		.modalias	= "ads7846",
-		.max_speed_hz	= 1200000,
-		.bus_num	= 0,
-		.chip_select	= 1,
-		.platform_data	= &ea313x_ads7846_info,
-		.controller_data= &ea313x_ads7846_chip,
-		.irq		= IRQ_PENDOWN,
-	},
-	{},
 	};
-	gpio_request(GPIO_MUART_CTS_N, "touchscreen CS");
-	gpio_direction_output(GPIO_MUART_CTS_N, 1);
 
-	return spi_register_board_info(info, 3);
+	return spi_register_board_info(&info, 1);
 }
 arch_initcall(lpc313x_spidev_register);
 #endif
@@ -531,38 +366,6 @@ arch_initcall(lpc313x_spimtd_register);
 #endif
 #endif
 
-#if defined(CONFIG_SND_USE_EA3131)
-
-static u64 audio_dmamask = 0xffffffffUL;
-static struct platform_device lpc313x_uda1380_device = {
-	.name		= "lpc313x-uda1380",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-static struct platform_device lpc313x_i2s_device = {
-	.name		= "lpc313x-i2s",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-static struct platform_device lpc313x_audio_device = {
-	.name		= "lpc313x-audio",
-	.id		= 0,
-	.dev		= {
-		.dma_mask = &audio_dmamask,
-		.coherent_dma_mask = 0xffffffffUL,
-	},
-};
-
-#endif
-
 static struct platform_device *devices[] __initdata = {
 	&lpc313x_mci_device,
 #if defined (CONFIG_MTD_NAND_LPC313X)
@@ -571,11 +374,6 @@ static struct platform_device *devices[]
 #if defined(CONFIG_SPI_LPC313X)
 	&lpc313x_spi_device,
 #endif
-#if defined(CONFIG_SND_USE_EA3131)
-	&lpc313x_uda1380_device,
-	&lpc313x_i2s_device,
-	&lpc313x_audio_device,
-#endif
 };
 
 static struct map_desc ea313x_io_desc[] __initdata = {
@@ -607,72 +405,6 @@ static struct map_desc ea313x_io_desc[]
 
 #define PCA9532_GPIO_BASE 0x340
 #define VBUS_PWR_EN	(6 + PCA9532_GPIO_BASE)
-#define START_STOP_LED	8  /*led5 */
-#define IDLE_LED	9  /*led6 */
-
-static struct pca9532_platform_data ea313x_leds = {
-	.gpio_base = PCA9532_GPIO_BASE,
-	.leds = {
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 1 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 2 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 3 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 4 */
-	{	.type = PCA9532_TYPE_GPIO }, /* key joy 5 */
-	{	.type = PCA9532_TYPE_GPIO }, /* OTP gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_BUS_EN gpio */
-	{	.type = PCA9532_TYPE_GPIO }, /* V_PWR_CTRL gpio */
-
-	{	.name = "ea313x:red:led5",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led6",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led7",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led8",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led9",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led10",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led11",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	{	.name = "ea313x:red:led12",
-		.state = PCA9532_OFF,
-		.type = PCA9532_TYPE_LED,
-	},
-	},
-	.psc = { 0, 0 },
-	.pwm = { 0, 0 },
-};
-
-static struct i2c_board_info ea313x_i2c_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("pca9532", 0x60),
-		.platform_data = &ea313x_leds,
-	},
-};
-
-#if defined(CONFIG_MACH_EA3152)
-static struct i2c_board_info ea3152_i2c1_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("lpc3152-psu", 0x0C),
-	},
-};
-#endif
 
 void lpc313x_vbus_power(int enable)
 {
@@ -680,28 +412,17 @@ void lpc313x_vbus_power(int enable)
 	gpio_set_value(VBUS_PWR_EN, enable);
 }
 
-static void __init ea313x_init(void)
+#if defined(CONFIG_MACH_GNUBLIN)
+static void __init gnublin_init(void)
 {
 	lpc313x_init();
+
 	/* register i2cdevices */
 	lpc313x_register_i2c_devices();
 	
-
 	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	/* add DM9000 device */
-	ea_add_device_dm9000();
-	
-	ea_add_device_ssd1289();
-
-	i2c_register_board_info(0, ea313x_i2c_devices,
-		ARRAY_SIZE(ea313x_i2c_devices));
-
-#if defined(CONFIG_MACH_EA3152)
-	i2c_register_board_info(1, ea3152_i2c1_devices,
-		ARRAY_SIZE(ea3152_i2c1_devices));
-#endif
 }
+#endif
 
 #if defined(CONFIG_USB_EHCI_HCD)
 static void __init ea_usb_power(void)
@@ -720,26 +441,13 @@ static void __init ea313x_map_io(void)
 	iotable_init(ea313x_io_desc, ARRAY_SIZE(ea313x_io_desc));
 }
 
-#if defined(CONFIG_MACH_EA3152)
-MACHINE_START(EA3152, "NXP EA3152")
-	/* Maintainer: Durgesh Pattamatta, NXP */
-	.boot_params	= 0x30000100,
-	.map_io		= ea313x_map_io,
-	.init_irq	= lpc313x_init_irq,
-	.timer		= &lpc313x_timer,
-	.init_machine	= ea313x_init,
-MACHINE_END
-#endif
-
 #if defined(CONFIG_MACH_GNUBLIN)
-MACHINE_START(EA313X, "NXP EA313X")
+MACHINE_START(GNUBLIN, "GNUBLIN")
 	/* Maintainer: Durgesh Pattamatta, NXP */
 	.map_io		= ea313x_map_io,
 	.init_irq	= lpc313x_init_irq,
 	.timer		= &lpc313x_timer,
-	.init_machine	= ea313x_init,
+	.init_machine	= gnublin_init,
 	.restart	= arch_reset,
 MACHINE_END
 #endif
-
-
